### **소프트웨어 카탈로그 및 배포 오케스트레이터: 개발 기획안**

* **문서 버전:** v1.0
* **최종 수정일:** 2025년 8월 25일
* **작성자:** 📝 개발 기획자 (Gemini)

-----

### **1. 📜 프로젝트 개요**

본 프로젝트는 **폐쇄망 환경** 내에서 Sonatype Nexus를 중심으로 소프트웨어 자산을 관리하고, 복잡한 배포 과정을 자동화하는 **중앙화된 오케스트레이션 플랫폼**을 구축하는 것을 목표로 합니다. 이를
통해 휴먼 에러를 최소화하고, 소프트웨어 배포의 일관성, 안정성, 추적성을 확보하고자 합니다.

#### **핵심 목표**

* **중앙 카탈로그**: Nexus에 저장된 소프트웨어의 검색 및 정보 조회 기능 제공.
* **자동화된 배포**: 사용자가 UI를 통해 선택한 소프트웨어를 지정된 Kubernetes 클러스터 또는 가상머신(VM)에 원클릭으로 배포.
* **환경 관리**: 다수의 배포 대상 환경 정보와 인증 정보를 안전하게 관리.
* **가시성 확보**: 모든 배포 활동에 대한 이력과 로그를 기록하고 조회하는 기능 제공.

-----

### **2. 🏛️ 시스템 아키텍처**

시스템은 현대적인 분산 아키텍처를 따르며, 핵심 API 서버를 중심으로 구성됩니다.

#### **2.1. 구성도**

```
+----------------+      +--------------------------+      +---------------------------+
|   웹 UI        |  ->  |  오케스트레이터 API 서버    |  ->  | Sonatype Nexus 리포지토리 |
|   (Vue.js)     |      |    (Java / Spring Boot)  |      | (아티팩트 및 의존성 허브)   |
+----------------+      +--------------------------+      +---------------------------+
                        +------------+-------------+
                                     | (배포 명령)
            +------------------------+------------------------+
            | (K8s API)                                       | (SSH)
            v                                                 v
+---------------------------+             +---------------------------+
| Kubernetes 클러스터        |             | 가상 머신 (VM)            |
+---------------------------+             +---------------------------+
```

#### **2.2. 컴포넌트별 역할**

* **오케스트레이터 API 서버**: 시스템의 두뇌. 카탈로그 조회, 배포 워크플로우 실행, 이력 관리 등 모든 비즈니스 로직을 처리합니다.
* **웹 UI**: 사용자를 위한 인터페이스. Vue.js 기반의 단일 페이지 애플리케이션(SPA)으로, 모든 통신은 API 서버를 통해서만 이루어집니다.
* **Sonatype Nexus**: 폐쇄망 환경의 생명선. 모든 소프트웨어 자산(Java/npm 라이브러리, Docker 이미지, 배포용 패키지)을 관리하는 단일 소스 저장소(Single Source of
  Truth)입니다.
* **대상 환경**: 소프트웨어가 실제로 배포되는 Kubernetes 클러스터 및 VM 서버입니다.

-----

### **3. 🛠️ 기술 스택**

| 구분          | 기술                         | 선정 사유                                     |
|:------------|:---------------------------|:------------------------------------------|
| **백엔드**     | Java 17+ & Spring Boot 3.x | 검증된 안정성, 생산성 및 강력한 생태계                    |
| **프론트엔드**   | Vue.js                     | 반응형 UI 구축을 위한 현대적인 컴포넌트 기반 프레임워크          |
| **데이터베이스**  | PostgreSQL                 | 유연한 데이터 저장을 위한 JSONB를 지원하는 강력한 오픈소스 RDBMS |
| **유효성 검증**  | Jakarta Bean Validation    | 선언적 유효성 검증을 통한 안정적인 API 구축                |
| **인메모리 DB** | H2 Database                | 로컬 환경에서의 개발, 테스트 및 빠른 프로토타이핑에 용이          |
| **CI/CD**   | Docker, Jenkins/GitLab CI  | 빌드/배포 파이프라인의 컨테이너화 및 자동화                  |

-----

### **4. 🔒 폐쇄망 환경 구성 전략 (필수 선행 조건)**

폐쇄망 운영을 위해서는 의존성 관리에 대한 치밀한 계획이 필요합니다.

#### **4.1. Nexus 리포지토리 구성**

Nexus를 포괄적인 내부 미러 저장소로 구성하는 것은 프로젝트의 **0단계(Phase 0)** 입니다.

* **그룹 리포지토리**: 개발자와 CI/CD 도구에 단일 접근점을 제공하기 위해 `group` 리포지토리를 생성합니다.
    * **`maven-internal-group`**: Maven Central의 `proxy` 저장소와 내부 산출물을 위한 `hosted` 저장소를 결합합니다.
    * **`npm-internal-group`**: npm 레지스트리의 `proxy` 저장소와 내부 패키지를 위한 `hosted` 저장소를 결합합니다.
    * **`docker-internal-group`**: Docker Hub의 `proxy` 저장소(베이스 이미지용)와 애플리케이션 이미지를 위한 `hosted` 레지스트리를 결합합니다.
* **초기 데이터 적재**: 개발 시작 전, 필요한 모든 외부 의존성을 파악하여 프록시 리포지토리에 미리 캐싱해 두어야 합니다.

-----

### **5. 📝 상세 설계**

애플리케이션의 내부 구조와 규약을 정의합니다.

#### **5.1. 백엔드 프로젝트 구조**

도메인 주도 설계를 따라 명확성과 유지보수성을 높인 계층형 아키텍처를 사용합니다.

```
com.appcatalog.orchestrator
├── OrchestratorApplication.java
├── config/                  // Spring Security, Async, Swagger 등 설정
├── error/                   // 전역 예외 처리, 커스텀 예외
├── catalog/                 // Nexus 연동 로직
│   ├── CatalogController.java
│   └── CatalogService.java
├── deployment/              // 핵심 배포 로직
│   ├── DeploymentController.java
│   ├── DeploymentService.java
│   ├── dto/                 // 데이터 전송 객체 (예: DeploymentRequest)
│   ├── strategy/            // 배포 전략 (K8sDeployer, VmDeployer)
│   └── domain/              // JPA 엔티티 및 리포지토리 (DeploymentJob)
└── target/                  // 배포 대상 환경 관리
    ├── TargetController.java
    ├── TargetService.java
    └── domain/              // JPA 엔티티 및 리포지토리 (TargetEnvironment)
```

#### **5.2. API 명세 (초안)**

API는 프론트엔드와 백엔드 간의 약속입니다.

* `POST /api/deployments`: 신규 배포를 시작합니다.
    * **Request Body**: 유효성 검증(`@Valid`)이 적용된 `DeploymentRequest` DTO.
* `GET /api/deployments/{id}`: 특정 배포의 상태 및 로그를 조회합니다.
* `GET /api/catalog/services`: Nexus 카탈로그에서 소프트웨어를 검색합니다.
* `GET /api/targets`: 등록된 모든 배포 대상을 조회합니다.

#### **5.3. 데이터 모델 (초안)**

* **`TARGET_ENVIRONMENTS`**: 대상 이름, 타입(K8S, VM), 연결 정보(JSONB)를 저장합니다.
* **`DEPLOYMENT_JOBS`**: 각 배포의 마스터 정보(서비스명, 버전, 대상, 상태, 타임스탬프)를 저장합니다.
* **`DEPLOYMENT_LOGS`**: 각 배포 작업에 대한 상세 로그를 저장합니다.

#### **5.4. 핵심 배포 워크플로우**

1. **요청 (동기)**: `DeploymentController`는 유효성이 검증된 `DeploymentRequest` DTO를 받습니다. 즉시 `DEPLOYMENT_JOBS`에 `PENDING` 상태로 작업을
   기록하고 사용자에게 접수 완료를 알립니다.
2. **실행 (비동기)**: `DeploymentService`는 `@Async` 메서드를 호출하여 실제 배포 프로세스를 처리함으로써 API 타임아웃을 방지합니다.
3. **전략 선택**: 서비스는 대상 타입에 따라 적절한 전략(`K8sDeployer` 또는 `VmDeployer`)을 선택합니다.
4. **처리**: 선택된 Deployer가 Nexus에서 아티팩트를 가져와 대상에 연결한 후, 배포를 실행하고 로그를 수집합니다.
5. **갱신**: 데이터베이스의 작업 상태가 `SUCCESS` 또는 `FAILED`로 업데이트되고 로그가 저장됩니다. UI는 작업 상태 API를 주기적으로 호출(Polling)하여 변경 사항을 반영합니다.

-----

### **6. ⚠️ 기술적 리스크 및 해결 방안**

| 리스크                | 해결 방안                                                                                    |
|:-------------------|:-----------------------------------------------------------------------------------------|
| **VM 환경의 비일관성**    | 배포 패키지(`deploy.sh` 스크립트가 포함된 `tar.gz` 등)를 표준화합니다. 멱등성 보장을 위해 Ansible Playbook 도입을 고려합니다. |
| **인증 정보의 불안전한 저장** | 데이터베이스에 인증 정보를 저장하지 않습니다. HashiCorp Vault와 같은 전문 시크릿 관리 도구와 연동합니다.                       |
| **배포 상태 불일치**      | 실패한 배포에 대한 강력한 에러 처리 및 정리(cleanup) 절차를 구현합니다. 오케스트레이터가 배포 상태의 유일한 진실 공급원(SSoT)이 되어야 합니다. |

-----

### **7. 🗺️ 개발 로드맵**

* **0단계: 환경 구축 (선행 조건)**
    * 4번 항목에 정의된 대로 Nexus 서버를 구축하고 리포지토리를 구성합니다.
    * `pom.xml`, `.npmrc` 설정 방법을 포함한 개발 환경 가이드를 작성합니다.
* **1단계: 최소 기능 제품 (MVP)**
    * 카탈로그 조회 및 VM 대상 배포를 위한 UI/UX를 구현합니다.
    * 표준 아티팩트를 VM에 SSH를 통해 배포하는 핵심 백엔드 로직을 개발합니다.
* **2단계: 기능 확장**
    * Kubernetes를 배포 대상으로 추가합니다.
    * 사용자 인증 및 기본적인 역할 관리 기능을 구현합니다.
* **3단계: 고도화 및 안정화**
    * 시크릿 관리 도구(Vault)를 연동합니다.
    * 배포 승인 워크플로우, 상세 대시보드 등 고급 기능을 구현합니다.